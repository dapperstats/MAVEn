exp_end_time <- df$Seconds[time_list[length(time_list)]]
exp_end_time
length(time_list)
time_list[length(time_list)]
time_from_df_end <- nrow(df) - time_list[length(time_list)]
time_from_df_end
nrow(df) - time_from_df_end - exp_start_time
n_cycles <- nrow(df) - time_from_df_end - exp_start_time / (cycle_duration)
n_cycles
n_cycles <- (nrow(df) - time_from_df_end - exp_start_time) / (cycle_duration)
n_cycles
n_cycles <- ceiling(n_cycles)
for (i in 1:n_cycles) {
df[df$Seconds >= time_list[i] &
df$Seconds <= time_list[i + 1], "cycle"] <- i
}
time_list <- unique(c(df$Seconds[df$Chamber == 1][1],
df$Seconds[which(diff.list > 1) + 1],
df$Seconds[nrow(df)]))
time_list
cycle_duration <- n_chambers * chamber_measure_duration
n_cycles <- (nrow(df) - df$Seconds[time_list[1]]) / (cycle_duration)
n_cycles <- ceiling(n_cycles)
for (i in 1:n_cycles) {
df[df$Seconds >= time_list[i] &
df$Seconds <= time_list[i + 1], "cycle"] <- i
}
df$Seconds[dim(df)[1]]
cycle_duration * n_cycles - df$Seconds[time_list[1]]
df$Seconds[cycle_duration * n_cycles - df$Seconds[time_list[1]]]
df$Seconds[time_list[1]]
df$Seconds[cycle_duration * n_cycles] - df$Seconds[time_list[1]]
df$Seconds[cycle_duration * n_cycles]
cycle_duration * n_cycles
time_list
time_list + 1920
time_list[4] + 1920
tail(time_list, n = 2)[1] + cycle_duration
df$Seconds[dim(df)[1]] <= tail(time_list, n = 2)[1] + cycle_duration)
(df$Seconds[dim(df)[1]] <= tail(time_list, n = 2)[1] + cycle_duration))
tail(time_list, n = 2)[1] + cycle_duration)
tail(time_list, n = 2)[1] + cycle_duration
df$Seconds[dim(df)[1]]
df$Seconds[dim(df)[1]] <= tail(time_list, n = 2)[1] + cycle_duration
df$Seconds[dim(df)[1]]
end_lastcycle <- tail(time_list, n = 2)[1] + cycle_duration)
end_lastcycle <- tail(time_list, n = 2)[1] + cycle_duration
(df$Seconds[dim(df)[1]] <= end_lastcycle)
end_lastcycle
df$Seconds[dim(df)[1]]
tail(time_list, n = 2)[1]
if(df$Seconds[dim(df)[1]] <= end_lastcycle){
df <- df %>% mutate(cycle = ifelse(Seconds >= tail(time_list, n = 2)[1], NA, cycle))
}
max(df$cycle)
df <-  maven %>% arrange(Seconds)
diff.list <- c()
# Detect the difference between a row and use it as an indicator for
#   the start of the next cycle
for (i in 2:length(df$Chamber)) {
diff <- df$Chamber[i - 1] - df$Chamber[i]
diff.list <- append(diff.list, diff)
}
# In some cases, the first value may not be detected because of where
#   the instrument starts its reading.
# This time_list will go through the end of the dataframe
time_list <- unique(c(df$Seconds[df$Chamber == 1][1],
df$Seconds[which(diff.list > 1) + 1],
df$Seconds[nrow(df)]))
cycle_duration <- n_chambers * chamber_measure_duration
n_cycles <- (nrow(df) - df$Seconds[time_list[1]]) / (cycle_duration)
n_cycles <- ceiling(n_cycles)
df$cycle <- "NA"
for (i in 1:n_cycles) {
df[df$Seconds >= time_list[i] &
df$Seconds <= time_list[i + 1], "cycle"] <- i
}
## detect if there is an incomplete cycle (i.e. instrument was shut off early)
end_lastcycle <- tail(time_list, n = 2)[1] + cycle_duration
if(df$Seconds[dim(df)[1]] <= end_lastcycle){
df <- df %>% mutate(cycle = ifelse(Seconds >= tail(time_list, n = 2)[1], "NA", cycle))
}
df
max(df$cycle)
df$cycle
unique(df$cycle)
df <-  maven %>% arrange(Seconds)
diff.list <- c()
# Detect the difference between a row and use it as an indicator for
#   the start of the next cycle
for (i in 2:length(df$Chamber)) {
diff <- df$Chamber[i - 1] - df$Chamber[i]
diff.list <- append(diff.list, diff)
}
# In some cases, the first value may not be detected because of where
#   the instrument starts its reading.
# This time_list will go through the end of the dataframe
time_list <- unique(c(df$Seconds[df$Chamber == 1][1],
df$Seconds[which(diff.list > 1) + 1],
df$Seconds[nrow(df)]))
cycle_duration <- n_chambers * chamber_measure_duration
n_cycles <- (nrow(df) - df$Seconds[time_list[1]]) / (cycle_duration)
n_cycles <- ceiling(n_cycles)
df$cycle <- "NA"
for (i in 1:n_cycles) {
df[df$Seconds >= time_list[i] &
df$Seconds <= time_list[i + 1], "cycle"] <- i
}
## detect if there is an incomplete cycle (i.e. instrument was shut off early)
end_lastcycle <- tail(time_list, n = 2)[1] + cycle_duration
if(df$Seconds[dim(df)[1]] <= end_lastcycle){
df <- df %>% mutate(cycle = ifelse(Seconds >= tail(time_list, n = 2)[1], NA, cycle))
}
message(paste("There were", max(df$cycle, na.rm = T), "complete cycles detected in this dataset."))
return(df)
df$cycle
df <- as.data.frame(df)
str(df)
df$cycle <- as.factor(df$cycle)
max(df$cycle, na.rm = T)
df <-  maven %>% arrange(Seconds)
diff.list <- c()
# Detect the difference between a row and use it as an indicator for
#   the start of the next cycle
for (i in 2:length(df$Chamber)) {
diff <- df$Chamber[i - 1] - df$Chamber[i]
diff.list <- append(diff.list, diff)
}
# In some cases, the first value may not be detected because of where
#   the instrument starts its reading.
# This time_list will go through the end of the dataframe
time_list <- unique(c(df$Seconds[df$Chamber == 1][1],
df$Seconds[which(diff.list > 1) + 1],
df$Seconds[nrow(df)]))
cycle_duration <- n_chambers * chamber_measure_duration
n_cycles <- (nrow(df) - df$Seconds[time_list[1]]) / (cycle_duration)
n_cycles <- ceiling(n_cycles)
df$cycle <- "NA"
for (i in 1:n_cycles) {
df[df$Seconds >= time_list[i] &
df$Seconds <= time_list[i + 1], "cycle"] <- i
}
## detect if there is an incomplete cycle (i.e. instrument was shut off early)
end_lastcycle <- tail(time_list, n = 2)[1] + cycle_duration
if(df$Seconds[dim(df)[1]] <= end_lastcycle){
df <- df %>% mutate(cycle = ifelse(Seconds >= tail(time_list, n = 2)[1], NA, cycle))
}
df$cycle <- as.numeric(df$cycle)
df$cycle
max(df$cycle, na.rm = T)
# Function name will need to change; this function currently operates to detect
# the first time Chamber 1 is read in the dataseries and allows for a variable
# number of measurements per chamber. Waiting on James to confirm that this is
# how he wants to proceed.
# assign_cyclenumber
assign_cyclenumber <- function(maven,
n_chambers = 16,
chamber_measure_duration = 120) {
df <-  maven %>% arrange(Seconds)
diff.list <- c()
# Detect the difference between a row and use it as an indicator for
#   the start of the next cycle
for (i in 2:length(df$Chamber)) {
diff <- df$Chamber[i - 1] - df$Chamber[i]
diff.list <- append(diff.list, diff)
}
# In some cases, the first value may not be detected because of where
#   the instrument starts its reading.
# This time_list will go through the end of the dataframe
time_list <- unique(c(df$Seconds[df$Chamber == 1][1],
df$Seconds[which(diff.list > 1) + 1],
df$Seconds[nrow(df)]))
cycle_duration <- n_chambers * chamber_measure_duration
n_cycles <- (nrow(df) - df$Seconds[time_list[1]]) / (cycle_duration)
n_cycles <- ceiling(n_cycles)
df$cycle <- "NA"
for (i in 1:n_cycles) {
df[df$Seconds >= time_list[i] &
df$Seconds <= time_list[i + 1], "cycle"] <- i
}
## detect if there is an incomplete cycle (i.e. instrument was shut off early)
end_lastcycle <- tail(time_list, n = 2)[1] + cycle_duration
if(df$Seconds[dim(df)[1]] <= end_lastcycle){
df <- df %>% mutate(cycle = ifelse(Seconds >= tail(time_list, n = 2)[1], NA, cycle))
}
df$cycle <- as.numeric(df$cycle)
message(paste("There were", max(df$cycle, na.rm = T), "complete cycles detected in this dataset."))
return(df)
}
maven.cycle <- assign_cyclenumber(maven)
fly_metabolism <- extract_metabolism(maven.cycle)
metablism_trend(fly_metabolism, maven_experiment = "test.case")
df$cycle <- as.factor(df$cycle)
unique(df$cycle)
# Function name will need to change; this function currently operates to detect
# the first time Chamber 1 is read in the dataseries and allows for a variable
# number of measurements per chamber. Waiting on James to confirm that this is
# how he wants to proceed.
# assign_cyclenumber
assign_cyclenumber <- function(maven,
n_chambers = 16,
chamber_measure_duration = 120) {
df <-  maven %>% arrange(Seconds)
diff.list <- c()
# Detect the difference between a row and use it as an indicator for
#   the start of the next cycle
for (i in 2:length(df$Chamber)) {
diff <- df$Chamber[i - 1] - df$Chamber[i]
diff.list <- append(diff.list, diff)
}
# In some cases, the first value may not be detected because of where
#   the instrument starts its reading.
# This time_list will go through the end of the dataframe
time_list <- unique(c(df$Seconds[df$Chamber == 1][1],
df$Seconds[which(diff.list > 1) + 1],
df$Seconds[nrow(df)]))
cycle_duration <- n_chambers * chamber_measure_duration
n_cycles <- (nrow(df) - df$Seconds[time_list[1]]) / (cycle_duration)
n_cycles <- ceiling(n_cycles)
df$cycle <- "NA"
for (i in 1:n_cycles) {
df[df$Seconds >= time_list[i] &
df$Seconds <= time_list[i + 1], "cycle"] <- i
}
## detect if there is an incomplete cycle (i.e. instrument was shut off early)
end_lastcycle <- tail(time_list, n = 2)[1] + cycle_duration
if(df$Seconds[dim(df)[1]] <= end_lastcycle){
df <- df %>% mutate(cycle = ifelse(Seconds >= tail(time_list, n = 2)[1], NA, cycle))
}
df$cycle <- as.factor(df$cycle)
#message(paste("There were", max(df$cycle, na.rm = T), "complete cycles detected in this dataset."))
return(df)
}
maven.cycle <- assign_cyclenumber(maven)
fly_metabolism <- extract_metabolism(maven.cycle)
# Function name will need to change; this function currently operates to detect
# the first time Chamber 1 is read in the dataseries and allows for a variable
# number of measurements per chamber. Waiting on James to confirm that this is
# how he wants to proceed.
# assign_cyclenumber
assign_cyclenumber <- function(maven,
n_chambers = 16,
chamber_measure_duration = 120) {
df <-  maven %>% arrange(Seconds)
diff.list <- c()
# Detect the difference between a row and use it as an indicator for
#   the start of the next cycle
for (i in 2:length(df$Chamber)) {
diff <- df$Chamber[i - 1] - df$Chamber[i]
diff.list <- append(diff.list, diff)
}
# In some cases, the first value may not be detected because of where
#   the instrument starts its reading.
# This time_list will go through the end of the dataframe
time_list <- unique(c(df$Seconds[df$Chamber == 1][1],
df$Seconds[which(diff.list > 1) + 1],
df$Seconds[nrow(df)]))
cycle_duration <- n_chambers * chamber_measure_duration
n_cycles <- (nrow(df) - df$Seconds[time_list[1]]) / (cycle_duration)
n_cycles <- ceiling(n_cycles)
df$cycle <- "NA"
for (i in 1:n_cycles) {
df[df$Seconds >= time_list[i] &
df$Seconds <= time_list[i + 1], "cycle"] <- i
}
## detect if there is an incomplete cycle (i.e. instrument was shut off early)
end_lastcycle <- tail(time_list, n = 2)[1] + cycle_duration
if(df$Seconds[dim(df)[1]] <= end_lastcycle){
df <- df %>% mutate(cycle = ifelse(Seconds >= tail(time_list, n = 2)[1], NA, cycle))
}
#df$cycle <- as.factor(df$cycle)
#message(paste("There were", max(df$cycle, na.rm = T), "complete cycles detected in this dataset."))
return(df)
}
maven.cycle <- assign_cyclenumber(maven)
fly_metabolism <- extract_metabolism(maven.cycle)
metablism_trend(fly_metabolism, maven_experiment = "test.case")
metabolism_summary_cycle <- summarize_metabolism(fly_metabolism, type = "by_cycle")
metabolism_diag(maven_raw, metabolism_summary_cycle, maven_experiment = "maven.example1")
# Step 1: load the MAVEn dataset without baseline ----
#  for workflow processing by toggling the baseline parameter.
maven <- read_maven(maven_datafile = "./truc2_MAVEn 129 2019-11-22_8WT-8mettl4b-eclOct23_males-R.csv", baseline = F)
maven.cycle <- assign_cyclenumber(maven)
fly_metabolism <- extract_metabolism(maven.cycle)
metablism_trend(fly_metabolism, maven_experiment = "test.case")
metabolism_summary_cycle <- summarize_metabolism(fly_metabolism, type = "by_cycle")
metabolism_diag(maven_raw, metabolism_summary_cycle, maven_experiment = "maven.example1")
code <- sapply(list.files(file.path(".", "R"), full.names = TRUE), source)
# Step 1: load the MAVEn dataset without baseline ----
#  for workflow processing by toggling the baseline parameter.
maven <- read_maven(maven_datafile = "./truc2_MAVEn 129 2019-11-22_8WT-8mettl4b-eclOct23_males-R.csv", baseline = F)
maven.cycle <- assign_cyclenumber(maven)
fly_metabolism <- extract_metabolism(maven.cycle)
metablism_trend(fly_metabolism, maven_experiment = "test.case")
maven <- read_maven(maven_datafile = "./maven_output.csv", baseline = F)
maven.cycle <- assign_cyclenumber(maven)
fly_metabolism <- extract_metabolism(maven.cycle)
metablism_trend(fly_metabolism, maven_experiment = "maven.example1")
fly_activity <- extract_activity(maven.cycle, metabolism_summary_cycle,
interval = 60, activity_baseline = 0.01)
metabolism_summary_cycle <- summarize_metabolism(fly_metabolism, type = "by_cycle")
metabolism_diag(maven_raw, metabolism_summary_cycle, maven_experiment = "maven.example1")
maven_raw <- read_maven(maven_datafile = "./maven_output.csv", baseline = T)
metabolism_diag(maven_raw, metabolism_summary_cycle, maven_experiment = "maven.example1")
fly_activity <- extract_activity(maven.cycle, metabolism_summary_cycle,
interval = 60, activity_baseline = 0.01)
activity_trend(fly_activity, maven_experiment = "maven.example1")
# Step 8: Visual diagnostic of fly activity ----
activity_diag(maven_raw, metabolism_summary_cycle, activity_summary_cycle,
maven_experiment = "maven_test", interval = 60)
# Step 7: Generate fly activity summary tables ----
#
# There is currently no calculation for the abs difference sum, but that can be
# added into the pipeline.
activity_summary_cycle <- summarize_activity(fly_activity, type = "by_cycle",
activity_threshold = 5)
# Step 8: Visual diagnostic of fly activity ----
activity_diag(maven_raw, metabolism_summary_cycle, activity_summary_cycle,
maven_experiment = "maven_test", interval = 60)
maven_raw %>% group_by(Chamber) %>% summarize_if(is.numeric, funs(mean, median))
maven_raw %>% group_by(Chamber) %>% summarize_if(is.numeric, list(mean, median))
maven_raw %>% Select(Chamber, CO2ppm:BP_kPa) %>% group_by(Chamber) %>% summarize_if(is.numeric, list(mean, median))
maven_raw %>% select(Chamber, CO2ppm:BP_kPa) %>% group_by(Chamber) %>% summarize_if(is.numeric, list(mean, median))
maven_raw %>% select(Chamber, CO2ppm:BP_kPa) %>% group_by(Chamber) %>% summarize_if(is.numeric, funs(mean, median))
fly_metabolism %>% select(Chamber, CO2ppm:BP_kPa) %>% group_by(Chamber) %>% summarize_if(is.numeric, funs(mean, median))
devtools::document()
devtools::use_vignette("MAVEn_workflow")
devtools::document()
code <- sapply(list.files(file.path(".", "R"), full.names = TRUE), source)
maven_raw <- read_maven(maven_datafile = "./maven_output.csv", baseline = T)
plot_maven_overview(maven_raw, maven_experiment = "maven.example1")
maven <- read_maven(maven_datafile = "./maven_output.csv", baseline = F)
maven.cycle <- assign_cyclenumber(maven)
maven.cycle
animal_metabolism <- extract_metabolism(maven.cycle)
metablism_trend(animal_metabolism, maven_experiment = "maven.example1")
metabolism_summary_cycle <- summarize_metabolism(animal_metabolism, type = "by_cycle")
metabolism_summary_chamber <- summarize_metabolism(animal_metabolism, type = "by_chamber")
metabolism_diag(maven_raw, metabolism_summary_cycle, maven_experiment = "maven.example1")
animal_activity <- extract_activity(maven.cycle, metabolism_summary_cycle,
interval = 60, activity_baseline = 0.01)
activity_trend(animal_activity, maven_experiment = "maven.example1")
# Step 7: Generate animal activity summary tables ----
#
# There is currently no calculation for the abs difference sum, but that can be
# added into the pipeline.
activity_summary_cycle <- summarize_activity(animal_activity, type = "by_cycle",
activity_threshold = 5)
activity_summary_chamber <- summarize_activity(animal_activity, type = "by_chamber")
# Step 8: Visual diagnostic of animal activity ----
activity_diag(maven_raw, metabolism_summary_cycle, activity_summary_cycle,
maven_experiment = "maven_test", interval = 60)
# Step 7: Generate animal activity summary tables ----
#
# There is currently no calculation for the abs difference sum, but that can be
# added into the pipeline.
activity_summary_cycle <- summarize_activity(animal_activity, type = "by_cycle",
activity_threshold = 1)
# Step 8: Visual diagnostic of animal activity ----
activity_diag(maven_raw, metabolism_summary_cycle, activity_summary_cycle,
maven_experiment = "maven.example1", interval = 60)
test.out <- maven_datatable(metabolism_summary_cycle, activity_summary_cycle, maven_experiment = "maven.example1")
ggplot(test.out, aes(x = activity_state, y = median_co2_ul.h)) +
geom_boxplot() +
geom_point(position = position_jitter(width = .2)) +
labs(title = "Activity State", x = "", y = expression(Median~CO[2]~(mu*L~h^-1)))
ggplot(test.out, aes(x = activity_state, y = median_co2_ul.h, col = cycle)) +
geom_boxplot() +
geom_point(position = position_jitter(width = .2)) +
labs(title = "Activity State", x = "", y = expression(Median~CO[2]~(mu*L~h^-1)))
ggplot(test.out, aes(x = activity_state, y = median_co2_ul.h, col = cycle)) +
geom_boxplot() +
geom_point(position = position_jitterdodge(width = .2)) +
labs(title = "Activity State", x = "", y = expression(Median~CO[2]~(mu*L~h^-1)))
ggplot(test.out, aes(x = activity_state, y = median_co2_ul.h, col = cycle)) +
geom_boxplot() +
geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.2)) +
labs(title = "Activity State", x = "", y = expression(Median~CO[2]~(mu*L~h^-1)))
ggplot(test.out, aes(x = activity_state, y = median_co2_ul.h, col = cycle)) +
geom_boxplot() +
geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 2)) +
labs(title = "Activity State", x = "", y = expression(Median~CO[2]~(mu*L~h^-1)))
ggplot(test.out, aes(x = activity_state, y = median_co2_ul.h, col = cycle)) +
geom_boxplot() +
geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 1)) +
labs(title = "Activity State", x = "", y = expression(Median~CO[2]~(mu*L~h^-1)))
ggplot(test.out, aes(x = activity_state, y = median_co2_ul.h, col = cycle)) +
geom_boxplot() +
geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.5)) +
labs(title = "Activity State", x = "", y = expression(Median~CO[2]~(mu*L~h^-1)))
ggplot(test.out, aes(x = activity_state, y = median_co2_ul.h, col = cycle)) +
geom_boxplot() +
geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.3)) +
labs(title = "Activity State", x = "", y = expression(Median~CO[2]~(mu*L~h^-1)))
ggplot(test.out, aes(x = activity_state, y = median_co2_ul.h, col = cycle)) +
geom_boxplot() +
geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.7)) +
labs(title = "Activity State", x = "", y = expression(Median~CO[2]~(mu*L~h^-1)))
## Complete analysis workflow ----
evaluate_maven(maven_datafile = "maven_output.csv", maven_experiment = "test.evaluate",
activity_baseline = 0.01, activity_threshold = 1)
## Complete analysis workflow ----
evaluate_maven(maven_datafile = "maven_output.csv", maven_experiment = "test.evaluate",
activity_baseline = 0.01, activity_threshold = 1)
evaluate_maven <- function(datadir = "data", outdir = "output",
maven_datafile = "./maven_output.csv",
maven_experiment = "",
interval = 60,
activity_baseline = 0.01,
activity_threshold = 1,
figures = c("trend","diag","overview")){
maven <- read_maven(maven_datafile = maven_datafile, baseline = F)
maven.cycle <- assign_cyclenumber(maven)
animal_metabolism <- extract_metabolism(maven.cycle)
metabolism_summary_cycle <- summarize_metabolism(animal_metabolism, type = "by_cycle")
animal_activity <- extract_activity(maven.cycle, metabolism_summary_cycle,
interval = interval,
activity_baseline = activity_baseline)
activity_summary_cycle <- summarize_activity(animal_activity, type = "by_cycle",
activity_threshold = activity_threshold)
out <- maven_datatable(metabolism_summary_cycle, activity_summary_cycle,
maven_experiment = maven_experiment)
if ("overview" %in% figures) {
maven_raw <- read_maven(maven_datafile = maven_datafile, baseline = T)
plot_maven_overview(maven_raw, maven_experiment = maven_experiment)
}
if ("trend" %in% figures){
metablism_trend(animal_metabolism, maven_experiment = maven_experiment)
activity_trend(animal_activity, maven_experiment = maven_experiment)
}
if ("diag" %in% figures){
metabolism_diag(maven_raw, metabolism_summary_cycle,
maven_experiment = maven_experiment)
activity_diag(maven_raw, metabolism_summary_cycle,
activity_summary_cycle,
maven_experiment = maven_experiment,
interval = interval)
}
return(out)
}
evaluate_maven <- function(datadir = "data", outdir = "output",
maven_datafile = "./maven_output.csv",
maven_experiment = "",
interval = 60,
activity_baseline = 0.01,
activity_threshold = 1,
figures = c("trend","diag","overview")){
# Load data
maven <- read_maven(maven_datafile = maven_datafile, baseline = F)
# assign a cycle
maven.cycle <- assign_cyclenumber(maven)
# animal metabolism
animal_metabolism <- extract_metabolism(maven.cycle)
metabolism_summary_cycle <- summarize_metabolism(animal_metabolism, type = "by_cycle")
#animal activity
animal_activity <- extract_activity(maven.cycle, metabolism_summary_cycle,
interval = interval,
activity_baseline = activity_baseline)
activity_summary_cycle <- summarize_activity(animal_activity, type = "by_cycle",
activity_threshold = activity_threshold)
# final data table
out <- maven_datatable(metabolism_summary_cycle, activity_summary_cycle,
maven_experiment = maven_experiment)
if ("overview" %in% figures) {
maven_raw <- read_maven(maven_datafile = maven_datafile, baseline = T)
plot_maven_overview(maven_raw, maven_experiment = maven_experiment)
}
if ("trend" %in% figures){
metablism_trend(animal_metabolism, maven_experiment = maven_experiment)
activity_trend(animal_activity, maven_experiment = maven_experiment)
}
if ("diag" %in% figures){
metabolism_diag(maven_raw, metabolism_summary_cycle,
maven_experiment = maven_experiment)
activity_diag(maven_raw, metabolism_summary_cycle,
activity_summary_cycle,
maven_experiment = maven_experiment,
interval = interval)
}
return(out)
}
## Complete analysis workflow ----
evaluate_maven(maven_datafile = "maven_output.csv", maven_experiment = "test.evaluate",
activity_baseline = 0.01, activity_threshold = 1)
datadir = "data"
outdir = "output"
maven_datafile = "./maven_output.csv"
# Load data
maven <- read_maven(maven_datafile = maven_datafile, baseline = F)
# assign a cycle
maven.cycle <- assign_cyclenumber(maven)
# animal metabolism
animal_metabolism <- extract_metabolism(maven.cycle)
install.packages("rmarkdown")
install.packages("rmarkdown")
library(rmarkdown)
devtools::use_vignette("MAVEn_workflow")
devtools::build_vignette("MAVEn_workflow")
library(devtools)
devtools::build_vignette("MAVEn_workflow")
build_vignette("MAVEn_workflow")
install.packages(c("callr", "CARBayes", "caret", "clv", "crosstalk", "diffobj", "DT", "flexCWM", "georob", "GGally", "ggraph", "glue", "h2o", "HandTill2001", "heatmaply", "hexbin", "Hmisc", "hydroGOF", "hydroPSO", "hydroTSM", "icenReg", "igraph", "indicspecies", "inlmisc", "JADE", "janitor", "jsonlite", "klaR", "knitr", "ks", "labelled", "laeken", "landsat", "landscapemetrics", "latentnet", "latticeExtra", "lava", "leaps", "leiden", "lifecycle", "locfit", "lpSolve", "lwgeom", "magclass", "manipulateWidget", "mapedit", "mapproj", "MASS", "matrixStats", "maxLik", "mboost", "mcmc", "MCMCpack", "metacom", "mice", "mime", "missMDA", "mixAK", "mixtools", "mlr", "mlt", "mmap", "mnormt", "MOCCA", "model4you", "ModelMetrics", "modelr", "modeltools", "mrds", "msm", "multcompView", "mvtnorm", "NADA", "naivebayes", "ncf", "ncvreg", "nFactors", "nlme", "nloptr", "nsRFA", "oce", "optimx", "optpart", "opusminer", "ordinal", "oro.nifti", "parallelMap", "ParamHelpers", "party", "partykit", "pbdBASE", "pbdMPI", "pbdSLAP", "pbkrtest", "pedometrics", "phylobase", "picante", "plm", "plotKML", "plotly", "plyr", "popbio", "prabclus", "pracma", "prcr", "prettyunits", "prim", "pROC", "processx", "protolite", "ps", "pscl", "psych", "psychomix", "psychotools", "quantmod", "R.methodsS3", "R2admb", "ramps", "RandomFields", "randomForestSRC", "randtoolbox", "ranger", "raster", "rattle", "Rcapture", "Rcmdr", "RcmdrMisc", "rcosmo", "Rcpp", "RcppAnnoy", "RcppArmadillo", "RcppParallel", "RcppProgress", "recipes", "recmap", "Rfast", "Rfast2", "rgbif", "rgexf", "rgl", "RgoogleMaps", "RhpcBLASctl", "rJava", "rje", "rlang", "rminer", "rncl", "RNeXML", "rngWELL", "RNifti", "robCompositions", "robustbase", "rrcov", "rredlist", "RSQLite", "rstudioapi", "rsvd", "Rttf2pt1", "RWeka", "RXshrink", "secr", "seg", "sensitivity", "SensoMineR", "Seurat", "sf", "sfsmisc", "shiny", "shinyjs", "SIS", "slam", "smacof", "sn", "sp", "spacetime", "spaMM", "spatial.tools", "SpatialExtremes", "spatstat", "spatstat.data", "spatstat.utils", "spatsurv", "spBayes", "spBayesSurv", "spcosa", "spData", "spgwr", "spsurvey", "SQUAREM", "SSN", "statmod", "stplanr", "stringi", "subplex", "surveillance", "survey", "survival", "svglite", "taxize", "testthat", "tidycensus", "tidyr", "tidyselect", "tigris", "tinytex", "tmap", "TMB", "trend", "trimcluster", "tripack", "trust", "TSP", "units", "unmarked", "uuid", "uwot", "V8", "variables", "vcd", "vcr", "vcrpart", "vctrs", "VIM", "waveslim", "weathercan", "webmockr", "weights", "xfun", "xgboost", "XML", "xml2", "xts", "yaml", "zCompositions", "zoo"))
install.packages(c("callr", "CARBayes", "caret", "clv", "crosstalk", "diffobj", "DT", "flexCWM", "georob", "GGally", "ggraph", "glue", "h2o", "HandTill2001", "heatmaply", "hexbin", "Hmisc", "hydroGOF", "hydroPSO", "hydroTSM", "icenReg", "igraph", "indicspecies", "inlmisc", "JADE", "janitor", "jsonlite", "klaR", "knitr", "ks", "labelled", "laeken", "landsat", "landscapemetrics", "latentnet", "latticeExtra", "lava", "leaps", "leiden", "lifecycle", "locfit", "lpSolve", "lwgeom", "magclass", "manipulateWidget", "mapedit", "mapproj", "MASS", "matrixStats", "maxLik", "mboost", "mcmc", "MCMCpack", "metacom", "mice", "mime", "missMDA", "mixAK", "mixtools", "mlr", "mlt", "mmap", "mnormt", "MOCCA", "model4you", "ModelMetrics", "modelr", "modeltools", "mrds", "msm", "multcompView", "mvtnorm", "NADA", "naivebayes", "ncf", "ncvreg", "nFactors", "nlme", "nloptr", "nsRFA", "oce", "optimx", "optpart", "opusminer", "ordinal", "oro.nifti", "parallelMap", "ParamHelpers", "party", "partykit", "pbdBASE", "pbdMPI", "pbdSLAP", "pbkrtest", "pedometrics", "phylobase", "picante", "plm", "plotKML", "plotly", "plyr", "popbio", "prabclus", "pracma", "prcr", "prettyunits", "prim", "pROC", "processx", "protolite", "ps", "pscl", "psych", "psychomix", "psychotools", "quantmod", "R.methodsS3", "R2admb", "ramps", "RandomFields", "randomForestSRC", "randtoolbox", "ranger", "raster", "rattle", "Rcapture", "Rcmdr", "RcmdrMisc", "rcosmo", "Rcpp", "RcppAnnoy", "RcppArmadillo", "RcppParallel", "RcppProgress", "recipes", "recmap", "Rfast", "Rfast2", "rgbif", "rgexf", "rgl", "RgoogleMaps", "RhpcBLASctl", "rJava", "rje", "rlang", "rminer", "rncl", "RNeXML", "rngWELL", "RNifti", "robCompositions", "robustbase", "rrcov", "rredlist", "RSQLite", "rstudioapi", "rsvd", "Rttf2pt1", "RWeka", "RXshrink", "secr", "seg", "sensitivity", "SensoMineR", "Seurat", "sf", "sfsmisc", "shiny", "shinyjs", "SIS", "slam", "smacof", "sn", "sp", "spacetime", "spaMM", "spatial.tools", "SpatialExtremes", "spatstat", "spatstat.data", "spatstat.utils", "spatsurv", "spBayes", "spBayesSurv", "spcosa", "spData", "spgwr", "spsurvey", "SQUAREM", "SSN", "statmod", "stplanr", "stringi", "subplex", "surveillance", "survey", "survival", "svglite", "taxize", "testthat", "tidycensus", "tidyr", "tidyselect", "tigris", "tinytex", "tmap", "TMB", "trend", "trimcluster", "tripack", "trust", "TSP", "units", "unmarked", "uuid", "uwot", "V8", "variables", "vcd", "vcr", "vcrpart", "vctrs", "VIM", "waveslim", "weathercan", "webmockr", "weights", "xfun", "xgboost", "XML", "xml2", "xts", "yaml", "zCompositions", "zoo"))
install.packages(c("callr", "CARBayes", "caret", "clv", "crosstalk", "diffobj", "DT", "flexCWM", "georob", "GGally", "ggraph", "glue", "h2o", "HandTill2001", "heatmaply", "hexbin", "Hmisc", "hydroGOF", "hydroPSO", "hydroTSM", "icenReg", "igraph", "indicspecies", "inlmisc", "JADE", "janitor", "jsonlite", "klaR", "knitr", "ks", "labelled", "laeken", "landsat", "landscapemetrics", "latentnet", "latticeExtra", "lava", "leaps", "leiden", "lifecycle", "locfit", "lpSolve", "lwgeom", "magclass", "manipulateWidget", "mapedit", "mapproj", "MASS", "matrixStats", "maxLik", "mboost", "mcmc", "MCMCpack", "metacom", "mice", "mime", "missMDA", "mixAK", "mixtools", "mlr", "mlt", "mmap", "mnormt", "MOCCA", "model4you", "ModelMetrics", "modelr", "modeltools", "mrds", "msm", "multcompView", "mvtnorm", "NADA", "naivebayes", "ncf", "ncvreg", "nFactors", "nlme", "nloptr", "nsRFA", "oce", "optimx", "optpart", "opusminer", "ordinal", "oro.nifti", "parallelMap", "ParamHelpers", "party", "partykit", "pbdBASE", "pbdMPI", "pbdSLAP", "pbkrtest", "pedometrics", "phylobase", "picante", "plm", "plotKML", "plotly", "plyr", "popbio", "prabclus", "pracma", "prcr", "prettyunits", "prim", "pROC", "processx", "protolite", "ps", "pscl", "psych", "psychomix", "psychotools", "quantmod", "R.methodsS3", "R2admb", "ramps", "RandomFields", "randomForestSRC", "randtoolbox", "ranger", "raster", "rattle", "Rcapture", "Rcmdr", "RcmdrMisc", "rcosmo", "Rcpp", "RcppAnnoy", "RcppArmadillo", "RcppParallel", "RcppProgress", "recipes", "recmap", "Rfast", "Rfast2", "rgbif", "rgexf", "rgl", "RgoogleMaps", "RhpcBLASctl", "rJava", "rje", "rlang", "rminer", "rncl", "RNeXML", "rngWELL", "RNifti", "robCompositions", "robustbase", "rrcov", "rredlist", "RSQLite", "rstudioapi", "rsvd", "Rttf2pt1", "RWeka", "RXshrink", "secr", "seg", "sensitivity", "SensoMineR", "Seurat", "sf", "sfsmisc", "shiny", "shinyjs", "SIS", "slam", "smacof", "sn", "sp", "spacetime", "spaMM", "spatial.tools", "SpatialExtremes", "spatstat", "spatstat.data", "spatstat.utils", "spatsurv", "spBayes", "spBayesSurv", "spcosa", "spData", "spgwr", "spsurvey", "SQUAREM", "SSN", "statmod", "stplanr", "stringi", "subplex", "surveillance", "survey", "survival", "svglite", "taxize", "testthat", "tidycensus", "tidyr", "tidyselect", "tigris", "tinytex", "tmap", "TMB", "trend", "trimcluster", "tripack", "trust", "TSP", "units", "unmarked", "uuid", "uwot", "V8", "variables", "vcd", "vcr", "vcrpart", "vctrs", "VIM", "waveslim", "weathercan", "webmockr", "weights", "xfun", "xgboost", "XML", "xml2", "xts", "yaml", "zCompositions", "zoo"))
install.packages(c("callr", "CARBayes", "caret", "clv", "crosstalk", "diffobj", "DT", "flexCWM", "georob", "GGally", "ggraph", "glue", "h2o", "HandTill2001", "heatmaply", "hexbin", "Hmisc", "hydroGOF", "hydroPSO", "hydroTSM", "icenReg", "igraph", "indicspecies", "inlmisc", "JADE", "janitor", "jsonlite", "klaR", "knitr", "ks", "labelled", "laeken", "landsat", "landscapemetrics", "latentnet", "latticeExtra", "lava", "leaps", "leiden", "lifecycle", "locfit", "lpSolve", "lwgeom", "magclass", "manipulateWidget", "mapedit", "mapproj", "MASS", "matrixStats", "maxLik", "mboost", "mcmc", "MCMCpack", "metacom", "mice", "mime", "missMDA", "mixAK", "mixtools", "mlr", "mlt", "mmap", "mnormt", "MOCCA", "model4you", "ModelMetrics", "modelr", "modeltools", "mrds", "msm", "multcompView", "mvtnorm", "NADA", "naivebayes", "ncf", "ncvreg", "nFactors", "nlme", "nloptr", "nsRFA", "oce", "optimx", "optpart", "opusminer", "ordinal", "oro.nifti", "parallelMap", "ParamHelpers", "party", "partykit", "pbdBASE", "pbdMPI", "pbdSLAP", "pbkrtest", "pedometrics", "phylobase", "picante", "plm", "plotKML", "plotly", "plyr", "popbio", "prabclus", "pracma", "prcr", "prettyunits", "prim", "pROC", "processx", "protolite", "ps", "pscl", "psych", "psychomix", "psychotools", "quantmod", "R.methodsS3", "R2admb", "ramps", "RandomFields", "randomForestSRC", "randtoolbox", "ranger", "raster", "rattle", "Rcapture", "Rcmdr", "RcmdrMisc", "rcosmo", "Rcpp", "RcppAnnoy", "RcppArmadillo", "RcppParallel", "RcppProgress", "recipes", "recmap", "Rfast", "Rfast2", "rgbif", "rgexf", "rgl", "RgoogleMaps", "RhpcBLASctl", "rJava", "rje", "rlang", "rminer", "rncl", "RNeXML", "rngWELL", "RNifti", "robCompositions", "robustbase", "rrcov", "rredlist", "RSQLite", "rstudioapi", "rsvd", "Rttf2pt1", "RWeka", "RXshrink", "secr", "seg", "sensitivity", "SensoMineR", "Seurat", "sf", "sfsmisc", "shiny", "shinyjs", "SIS", "slam", "smacof", "sn", "sp", "spacetime", "spaMM", "spatial.tools", "SpatialExtremes", "spatstat", "spatstat.data", "spatstat.utils", "spatsurv", "spBayes", "spBayesSurv", "spcosa", "spData", "spgwr", "spsurvey", "SQUAREM", "SSN", "statmod", "stplanr", "stringi", "subplex", "surveillance", "survey", "survival", "svglite", "taxize", "testthat", "tidycensus", "tidyr", "tidyselect", "tigris", "tinytex", "tmap", "TMB", "trend", "trimcluster", "tripack", "trust", "TSP", "units", "unmarked", "uuid", "uwot", "V8", "variables", "vcd", "vcr", "vcrpart", "vctrs", "VIM", "waveslim", "weathercan", "webmockr", "weights", "xfun", "xgboost", "XML", "xml2", "xts", "yaml", "zCompositions", "zoo"))
install.packages(c("callr", "CARBayes", "caret", "clv", "crosstalk", "diffobj", "DT", "flexCWM", "georob", "GGally", "ggraph", "glue", "h2o", "HandTill2001", "heatmaply", "hexbin", "Hmisc", "hydroGOF", "hydroPSO", "hydroTSM", "icenReg", "igraph", "indicspecies", "inlmisc", "JADE", "janitor", "jsonlite", "klaR", "knitr", "ks", "labelled", "laeken", "landsat", "landscapemetrics", "latentnet", "latticeExtra", "lava", "leaps", "leiden", "lifecycle", "locfit", "lpSolve", "lwgeom", "magclass", "manipulateWidget", "mapedit", "mapproj", "MASS", "matrixStats", "maxLik", "mboost", "mcmc", "MCMCpack", "metacom", "mice", "mime", "missMDA", "mixAK", "mixtools", "mlr", "mlt", "mmap", "mnormt", "MOCCA", "model4you", "ModelMetrics", "modelr", "modeltools", "mrds", "msm", "multcompView", "mvtnorm", "NADA", "naivebayes", "ncf", "ncvreg", "nFactors", "nlme", "nloptr", "nsRFA", "oce", "optimx", "optpart", "opusminer", "ordinal", "oro.nifti", "parallelMap", "ParamHelpers", "party", "partykit", "pbdBASE", "pbdMPI", "pbdSLAP", "pbkrtest", "pedometrics", "phylobase", "picante", "plm", "plotKML", "plotly", "plyr", "popbio", "prabclus", "pracma", "prcr", "prettyunits", "prim", "pROC", "processx", "protolite", "ps", "pscl", "psych", "psychomix", "psychotools", "quantmod", "R.methodsS3", "R2admb", "ramps", "RandomFields", "randomForestSRC", "randtoolbox", "ranger", "raster", "rattle", "Rcapture", "Rcmdr", "RcmdrMisc", "rcosmo", "Rcpp", "RcppAnnoy", "RcppArmadillo", "RcppParallel", "RcppProgress", "recipes", "recmap", "Rfast", "Rfast2", "rgbif", "rgexf", "rgl", "RgoogleMaps", "RhpcBLASctl", "rJava", "rje", "rlang", "rminer", "rncl", "RNeXML", "rngWELL", "RNifti", "robCompositions", "robustbase", "rrcov", "rredlist", "RSQLite", "rstudioapi", "rsvd", "Rttf2pt1", "RWeka", "RXshrink", "secr", "seg", "sensitivity", "SensoMineR", "Seurat", "sf", "sfsmisc", "shiny", "shinyjs", "SIS", "slam", "smacof", "sn", "sp", "spacetime", "spaMM", "spatial.tools", "SpatialExtremes", "spatstat", "spatstat.data", "spatstat.utils", "spatsurv", "spBayes", "spBayesSurv", "spcosa", "spData", "spgwr", "spsurvey", "SQUAREM", "SSN", "statmod", "stplanr", "stringi", "subplex", "surveillance", "survey", "survival", "svglite", "taxize", "testthat", "tidycensus", "tidyr", "tidyselect", "tigris", "tinytex", "tmap", "TMB", "trend", "trimcluster", "tripack", "trust", "TSP", "units", "unmarked", "uuid", "uwot", "V8", "variables", "vcd", "vcr", "vcrpart", "vctrs", "VIM", "waveslim", "weathercan", "webmockr", "weights", "xfun", "xgboost", "XML", "xml2", "xts", "yaml", "zCompositions", "zoo"))
install.packages(c("callr", "CARBayes", "caret", "clv", "crosstalk", "diffobj", "DT", "flexCWM", "georob", "GGally", "ggraph", "glue", "h2o", "HandTill2001", "heatmaply", "hexbin", "Hmisc", "hydroGOF", "hydroPSO", "hydroTSM", "icenReg", "igraph", "indicspecies", "inlmisc", "JADE", "janitor", "jsonlite", "klaR", "knitr", "ks", "labelled", "laeken", "landsat", "landscapemetrics", "latentnet", "latticeExtra", "lava", "leaps", "leiden", "lifecycle", "locfit", "lpSolve", "lwgeom", "magclass", "manipulateWidget", "mapedit", "mapproj", "MASS", "matrixStats", "maxLik", "mboost", "mcmc", "MCMCpack", "metacom", "mice", "mime", "missMDA", "mixAK", "mixtools", "mlr", "mlt", "mmap", "mnormt", "MOCCA", "model4you", "ModelMetrics", "modelr", "modeltools", "mrds", "msm", "multcompView", "mvtnorm", "NADA", "naivebayes", "ncf", "ncvreg", "nFactors", "nlme", "nloptr", "nsRFA", "oce", "optimx", "optpart", "opusminer", "ordinal", "oro.nifti", "parallelMap", "ParamHelpers", "party", "partykit", "pbdBASE", "pbdMPI", "pbdSLAP", "pbkrtest", "pedometrics", "phylobase", "picante", "plm", "plotKML", "plotly", "plyr", "popbio", "prabclus", "pracma", "prcr", "prettyunits", "prim", "pROC", "processx", "protolite", "ps", "pscl", "psych", "psychomix", "psychotools", "quantmod", "R.methodsS3", "R2admb", "ramps", "RandomFields", "randomForestSRC", "randtoolbox", "ranger", "raster", "rattle", "Rcapture", "Rcmdr", "RcmdrMisc", "rcosmo", "Rcpp", "RcppAnnoy", "RcppArmadillo", "RcppParallel", "RcppProgress", "recipes", "recmap", "Rfast", "Rfast2", "rgbif", "rgexf", "rgl", "RgoogleMaps", "RhpcBLASctl", "rJava", "rje", "rlang", "rminer", "rncl", "RNeXML", "rngWELL", "RNifti", "robCompositions", "robustbase", "rrcov", "rredlist", "RSQLite", "rstudioapi", "rsvd", "Rttf2pt1", "RWeka", "RXshrink", "secr", "seg", "sensitivity", "SensoMineR", "Seurat", "sf", "sfsmisc", "shiny", "shinyjs", "SIS", "slam", "smacof", "sn", "sp", "spacetime", "spaMM", "spatial.tools", "SpatialExtremes", "spatstat", "spatstat.data", "spatstat.utils", "spatsurv", "spBayes", "spBayesSurv", "spcosa", "spData", "spgwr", "spsurvey", "SQUAREM", "SSN", "statmod", "stplanr", "stringi", "subplex", "surveillance", "survey", "survival", "svglite", "taxize", "testthat", "tidycensus", "tidyr", "tidyselect", "tigris", "tinytex", "tmap", "TMB", "trend", "trimcluster", "tripack", "trust", "TSP", "units", "unmarked", "uuid", "uwot", "V8", "variables", "vcd", "vcr", "vcrpart", "vctrs", "VIM", "waveslim", "weathercan", "webmockr", "weights", "xfun", "xgboost", "XML", "xml2", "xts", "yaml", "zCompositions", "zoo"))
install.packages(c("callr", "CARBayes", "caret", "clv", "crosstalk", "diffobj", "DT", "flexCWM", "georob", "GGally", "ggraph", "glue", "h2o", "HandTill2001", "heatmaply", "hexbin", "Hmisc", "hydroGOF", "hydroPSO", "hydroTSM", "icenReg", "igraph", "indicspecies", "inlmisc", "JADE", "janitor", "jsonlite", "klaR", "knitr", "ks", "labelled", "laeken", "landsat", "landscapemetrics", "latentnet", "latticeExtra", "lava", "leaps", "leiden", "lifecycle", "locfit", "lpSolve", "lwgeom", "magclass", "manipulateWidget", "mapedit", "mapproj", "MASS", "matrixStats", "maxLik", "mboost", "mcmc", "MCMCpack", "metacom", "mice", "mime", "missMDA", "mixAK", "mixtools", "mlr", "mlt", "mmap", "mnormt", "MOCCA", "model4you", "ModelMetrics", "modelr", "modeltools", "mrds", "msm", "multcompView", "mvtnorm", "NADA", "naivebayes", "ncf", "ncvreg", "nFactors", "nlme", "nloptr", "nsRFA", "oce", "optimx", "optpart", "opusminer", "ordinal", "oro.nifti", "parallelMap", "ParamHelpers", "party", "partykit", "pbdBASE", "pbdMPI", "pbdSLAP", "pbkrtest", "pedometrics", "phylobase", "picante", "plm", "plotKML", "plotly", "plyr", "popbio", "prabclus", "pracma", "prcr", "prettyunits", "prim", "pROC", "processx", "protolite", "ps", "pscl", "psych", "psychomix", "psychotools", "quantmod", "R.methodsS3", "R2admb", "ramps", "RandomFields", "randomForestSRC", "randtoolbox", "ranger", "raster", "rattle", "Rcapture", "Rcmdr", "RcmdrMisc", "rcosmo", "Rcpp", "RcppAnnoy", "RcppArmadillo", "RcppParallel", "RcppProgress", "recipes", "recmap", "Rfast", "Rfast2", "rgbif", "rgexf", "rgl", "RgoogleMaps", "RhpcBLASctl", "rJava", "rje", "rlang", "rminer", "rncl", "RNeXML", "rngWELL", "RNifti", "robCompositions", "robustbase", "rrcov", "rredlist", "RSQLite", "rstudioapi", "rsvd", "Rttf2pt1", "RWeka", "RXshrink", "secr", "seg", "sensitivity", "SensoMineR", "Seurat", "sf", "sfsmisc", "shiny", "shinyjs", "SIS", "slam", "smacof", "sn", "sp", "spacetime", "spaMM", "spatial.tools", "SpatialExtremes", "spatstat", "spatstat.data", "spatstat.utils", "spatsurv", "spBayes", "spBayesSurv", "spcosa", "spData", "spgwr", "spsurvey", "SQUAREM", "SSN", "statmod", "stplanr", "stringi", "subplex", "surveillance", "survey", "survival", "svglite", "taxize", "testthat", "tidycensus", "tidyr", "tidyselect", "tigris", "tinytex", "tmap", "TMB", "trend", "trimcluster", "tripack", "trust", "TSP", "units", "unmarked", "uuid", "uwot", "V8", "variables", "vcd", "vcr", "vcrpart", "vctrs", "VIM", "waveslim", "weathercan", "webmockr", "weights", "xfun", "xgboost", "XML", "xml2", "xts", "yaml", "zCompositions", "zoo"))
devtools::build_vignette("MAVEn_workflow")
usethis::use_vignette("MAVEn_workflow")
activity_trend()
activity_trend
